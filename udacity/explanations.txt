###########################################################
# QUESTION 1
###########################################################

The algorithm works in a guaranteed linear time, O(N + M), where N is length of the first string and M is the length of the second.

It maintains a "repository" of available characters, which is initialized with all the characters from the second string.

There are two pointers that can only move left to right: current character and current anagram candidate start position.

Once current character can not be matched to an available place in the repository, the anagram start gets advanced.

Since we know that this is an ASCII string, the "repository" data structure is just a static array of 255 character counts (but it could be a dictionary as well).
This makes for a O(1) memory usage.

###########################################################
# QUESTION 2
###########################################################

Computational complexity is quadratic, O(N^2), I am using a simple algorithm here:
 - for which position inside the string find longest palindrome with the middle at that location. 
   At every location it's done for both odd and even palindrome character counts
 - the maximum of those is taken and the substring is extracted.

 Memory complexity is O(1).

 I am pretty sure it could have been done with a lower complexity, but no simple solution came to mind, so I left it at that.

###########################################################
# QUESTION 3
###########################################################

###########################################################
# QUESTION 4
###########################################################

###########################################################
# QUESTION 5
###########################################################

This one has a linear complexity, O(N) in computation and O(M) in memory 
(where N is the length of list and M is the element index to find from the end).


I am using an explicit deque data structure, as opposed to possibly writing a fancy recursive function,
because running the latter with big M could just blow up the stack.